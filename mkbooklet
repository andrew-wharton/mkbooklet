#!/usr/bin/python
import subprocess
import pyPdf
import sys
import os
import re
import tempfile
import shutil
import argparse

viewer = "evince"
texcomp = "pdflatex"



def median(l):
	l.sort()
	return l[len(l)/2]


parser = argparse.ArgumentParser(description='Prepare PDF files for booklet printing.')
parser.add_argument('-o', '--outer-margins', dest='margins', default=15, type=int, help='use given value (unit: postscript points) for the minimal outer margins')
parser.add_argument('-f', '--foldmargin', default=100, type=int, help='use given value (unit: postscript points) for the minimal fold margin')
parser.add_argument('-c', '--nocrop', action='store_true', default=False, help='do not crop the input file')
parser.add_argument('-C', '--croponly', action='store_true', default=False, help='only crop the input file, do not create a booklet')
parser.add_argument('-g', '--noguides', action='store_true', default=False, help='do not apply any guides on the first page')
parser.add_argument('-s', '--smartbbox', action='store_true', default=False, help='use the smart algorithm when obtaining the bbox')
parser.add_argument('-p', '--bboxpage', dest='bboxpage', type=int, action='store', default=None, help='use given page only to obtain the bounding box')
parser.add_argument('-b', '--bbox', action='store', default=None, help='use given bounding box, specified as either x1,y1,x2,y2 or x,y+w,h')
parser.add_argument('--version', action='version', version='%(prog)s 11.09a')
parser.add_argument('FILE')
args = parser.parse_args()

pdf_in = os.path.abspath(args.FILE)
margins = args.margins
foldmargin = args.foldmargin
nocrop = args.nocrop
noguides = args.noguides
croponly = args.croponly
bboxpage = args.bboxpage
smartbbox = args.smartbbox

tmpdir = tempfile.mkdtemp()
os.chdir(tmpdir)

# A4 in postscript points: 841 x 595 
a4lheight = 595
a4lwidth = 841

if not nocrop:
	if not args.bbox:
		# determine actual (printed) bounding box
		proc = subprocess.Popen(["/usr/bin/gs", "-sDEVICE=bbox", "-dBATCH", "-dNOPAUSE", "-c", "save", "pop", "-f", pdf_in], stdout=sys.stdout, stderr=subprocess.PIPE)

		bbox = []

		for line in proc.stderr:
			if line.startswith('%%BoundingBox: '):
				parts = line.split(' ')
				bbox.append((int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4])))

		if bboxpage:
			bbox = bbox[bboxpage-1]
		elif smartbbox:
			bboxs = [None] * 4
			for i in range(4):
				bboxs[i] = median(map(lambda x: x[i], bbox))
			bbox = tuple(bboxs)
		else:
			bbox = reduce(lambda x, y: (min(x[0], y[0]), min(x[1], y[1]), max(x[2], y[2]), max(x[3], y[3])), bbox)
	else:
		# x1,y1,x2,y2
		# x,y+w,h
		m = re.match('^(\\d+),(\\d+)(,|\\+)(\\d+),(\\d+)$', args.bbox)
		if not m:
			print 'Invalid bbox format, use x1,y1,x2,y2 or x,y+w,h'
			shutil.rmtree(tmpdir)
			sys.exit(-1)
		else:
			bbox = (int(m.group(1)), int(m.group(2)), int(m.group(4)), int(m.group(5)))
			if m.group(3) == '+':
				bbox = (bbox[0], bbox[1], bbox[0] + bbox[2], bbox[1] + bbox[3])

	# determine scaling factor to calc crop box
	w = bbox[2] - bbox[0]
	h = bbox[3] - bbox[1]
	maxw = (a4lwidth - foldmargin - 4 * margins) / 2
	maxh = a4lheight - 2 * margins
	s = float(maxw) / w
	if s * h > maxh:
		# exceeds height, scaling will free up more horizontal space. make sure we use this space where it makes sense (i.e., on the folding edge)
		s = float(maxh) / h
		foldmargin = int(a4lwidth - s * w * 2 - 4 * margins) 

	sm = int(margins / s)
	cbox = (bbox[0] - sm, bbox[1] - sm, bbox[2] + sm, bbox[3] + sm)

	# crop crop
	pi = pyPdf.PdfFileReader(file(pdf_in, "rb"))
	po = pyPdf.PdfFileWriter()

	for i in range(pi.getNumPages()):
		p = pi.getPage(i)
		
		p.cropBox.lowerLeft = (cbox[0] + p.mediaBox.lowerLeft[0], cbox[1] + p.mediaBox.lowerLeft[1])
		p.cropBox.upperRight = (cbox[2] + p.mediaBox.lowerLeft[0], cbox[3] + p.mediaBox.lowerLeft[1])

		p.bleedBox = p.cropBox
		p.trimBox = p.cropBox
		p.artBox = p.cropBox

		po.addPage(p)

	outputStream = file('cropped.pdf', 'wb')
	po.write(outputStream)
	outputStream.close()

tex = file("sig.tex", "w")
if not croponly:
	tex.write("""\\documentclass[a4paper,landscape]{article}
\\usepackage{pdfpages}
\\begin{document}
\\includepdf[pages=-,booklet=true,delta=%dpt 0]{%s}
\\end{document}""" % (foldmargin, pdf_in if nocrop else 'cropped.pdf'))
else:
	tex.write("""\\documentclass[a4paper]{article}
\\usepackage{pdfpages}
\\begin{document}
\\includepdf[pages=-]{cropped.pdf}
\\end{document}""")
tex.close()

os.system(texcomp + ' sig.tex')


# apply folding/stapling guides, if available
gridfile = os.path.join(os.getenv("HOME"), ".mkbooklet", "foldstaplegrid.pdf")
if os.path.exists(gridfile) and not noguides and not croponly:
	pi = pyPdf.PdfFileReader(file("sig.pdf", "rb"))
	po = pyPdf.PdfFileWriter()

	for i in range(pi.getNumPages()):
		p = pi.getPage(i)
		if i == 0:
			grid = pyPdf.PdfFileReader(file(gridfile, "rb"))
			p.mergePage(grid.getPage(0))
		po.addPage(p)

	outputStream = file('sigs.pdf', 'wb')
	po.write(outputStream)
	outputStream.close()

	os.system(viewer + ' sigs.pdf')
else:
	os.system(viewer + ' sig.pdf')

print 'cleanup:', tmpdir
shutil.rmtree(tmpdir)
