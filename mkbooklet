#!/usr/bin/python
import subprocess
import pyPdf
import sys
import os
import re
import tempfile
import shutil
import argparse
import struct

viewer = "evince"
texcomp = "pdflatex"

mm_in_pt = 2.83464567

def pdfbbox(filename):
	f = pyPdf.PdfFileReader(file(filename, 'rb'))
	pages = f.getNumPages()

	sizes = []

	for i in range(pages):
		p = f.getPage(i)
		sizes.append((int(round(p.mediaBox.getUpperRight_x() - p.mediaBox.getLowerLeft_x())), int(round(p.mediaBox.getUpperRight_y() - p.mediaBox.getLowerLeft_y()))))

	proc = subprocess.Popen(['/usr/bin/gs', '-q', '-dBATCH', '-dNOPAUSE', '-sDEVICE=bit', '-sOutputFile=%stdout', filename], stdout=subprocess.PIPE)

	bboxs = []

	for s in sizes:
		(w,h) = s
		bbox = (w-1, h-1, 0, 0)
		
		row_len = w / 8
		if w % 8 > 0:
			row_len += 1

		fmt = 'b' * row_len

		for y in range(h-1, -1, -1):
			row = proc.stdout.read(row_len)
			row = struct.unpack(fmt, row)
			# use low resolution for x-positions. this is
			# substantially faster and comes with an error
			# of at most 8pt \approx 2.8mm
			for x in range(0, w / 8):
				if row[x] != 0:
					bbox = (
						min(bbox[0], x * 8),
						min(bbox[1], y),
						max(bbox[2], x * 8 + 8),
						max(bbox[3], y + 2),
					)

		if bbox[0] < bbox[2] and bbox[1] < bbox[3]:
			bboxs.append(tuple(bbox))

	return bboxs


def mkemptypage(w, h):
	ws = '%f' % w
	hs = '%f' % h
	l = len(ws) + len(hs)

	tpl = '''%%PDF-1.1
%%\xc3\xad\xc3\xac\xc2\xa6"

1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj
2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 /MediaBox [0 0 %s %s] >> endobj
3 0 obj << /Type /Page /Parent 2 0 R /Resources << >> /Contents [] >> endobj

xref
0 4
0000000000 65535 f 
0000000019 00000 n 
0000000068 00000 n 
%010d 00000 n 
trailer << /Root 1 0 R /Size 4 >>
startxref
%d
%%%%EOF'''

	return tpl % (ws, hs, 143 + l, 221 + l)


def generate_guides(num, a5mode):
	vmargin = 6
	hmargin = 5 if a5mode else 2.5
	x = hmargin if a5mode else 148.5 - hmargin
	content = '2.83464567 0 0 2.83464567 0 0 cm 0.1 w 1 0 0 1 %f %d cm' % (x, vmargin)

	n = num
	h = 12 # mm
	sp = float(210 - h - 2*vmargin)/(n-1) 

	for i in range(n):
		if i != 0:
			content += "1 0 0 1 0 %f cm\n" % sp
		content += """
0 0 m
0 %d l
s
0 2 m
%c2 2 l
s
0 10 m
%c2 10 l
s
""" % (h, ' ' if a5mode else '-', ' ' if a5mode else '-')

	template = """%%PDF-1.5
%%%%%%%%%%
1 0 obj 
<<
/Kids [2 0 R]
/Count 1
/Type /Pages
>>
endobj 
3 0 obj 
<<
>>
endobj 
4 0 obj 
<<
/Length %d
>>
stream
q
Q
%s
endstream 
endobj 
2 0 obj 
<<
/Group 
<<
/CS /DeviceRGB
/Type /Group
/S /Transparency
>>
/Parent 1 0 R
/Resources 3 0 R
/MediaBox [0 0 841.889764 595.275591]
                
/Contents 4 0 R
/Type /Page
>>
endobj 
5 0 obj 
<<
/Pages 1 0 R
/Type /Catalog
>>
endobj 
6 0 obj 
<<
/Creator (mkbooklet http://github.com/pb-/mkbooklet)
/Producer (mkbooklet http://github.com/pb-/mkbooklet)
>>
endobj xref
0 7
0000000000 65535 f 
0000000015 00000 n 
%010d 00000 n 
0000000074 00000 n 
0000000097 00000 n 
%010d 00000 n 
%010d 00000 n 
trailer

<<
/Info 6 0 R
/Root 5 0 R
/Size 7
>>
startxref
%d
%%%%EOF""" % (4+len(content), content, 155+len(content), 351+len(content), 402+len(content), 531+len(content))
	return template

def median(l):
	l.sort()
	return l[len(l)/2]


parser = argparse.ArgumentParser(description='Prepare PDF files for booklet printing.', formatter_class=argparse.RawDescriptionHelpFormatter, epilog="""
Inner and outer margins have the following meanings.

+---------------+
|###############|
|#    @@:@@    #|
|# P1 @@:@@ P2 #|
|#    @@:@@    #|
|###############|
+---------------+

'#' is the outer margin (both dimensions) along the outline of
    the phyiscal paper.
'@' is the inner fold margin (horizontally) between the actual
    content and the center of the paper indicated by ':'.
""")
parser.add_argument('-5', '--a5', action='store_true', default=False, help='produce single A5 pages instead of 2-up A4')
parser.add_argument('-o', '--outer-margins', dest='margins', default='default', type=str, help='use given value (unit: millimeters) for the minimal outer margins, see below')
parser.add_argument('-i', '--inner-margins', dest='imargins', default='default', type=str, help='use given value (unit: millimeters) for the minimal inner (fold)margins, see below')
parser.add_argument('-c', '--nocrop', action='store_true', default=False, help='do not crop the input file')
parser.add_argument('-C', '--croponly', action='store_true', default=False, help='only crop the input file, do not create a booklet')
parser.add_argument('-g', '--noguides', action='store_true', default=False, help='do not apply any guides on the first page')
parser.add_argument('-s', '--smartbbox', action='store_true', default=False, help='use the smart algorithm when obtaining the bbox')
parser.add_argument('-p', '--bboxpage', dest='bboxpage', type=int, action='store', default=None, help='use given page only to obtain the bounding box')
parser.add_argument('-b', '--bbox', action='store', default=None, help='use given bounding box, specified as either x1,y1,x2,y2 or x,y+w,h')
parser.add_argument('--version', action='version', version='%(prog)s 11.10a')
parser.add_argument('FILE')
args = parser.parse_args()

pdf_in = os.path.abspath(args.FILE)
a5mode = args.a5
margins = 6 if args.margins == 'default' else int(args.margins)
if args.imargins == 'default':
	if a5mode:
		imargins = 16
	else:
		imargins = 22
else:
	imargins = int(args.imargins)

if not a5mode:
	imargins = 2 * (imargins - margins)

margins = int(round(margins * mm_in_pt))
foldmargin = int(round(imargins * mm_in_pt))
nocrop = args.nocrop
noguides = args.noguides
croponly = args.croponly
bboxpage = args.bboxpage
smartbbox = args.smartbbox

tmpdir = tempfile.mkdtemp(prefix='mkbooklet-')
os.chdir(tmpdir)

# A4 in postscript points: 841 x 595 
a4lheight = 595
a4lwidth = 841
a5height = 595
a5width = 419

if not nocrop:
	if not args.bbox:
		# determine actual (printed) bounding box
		bbox = pdfbbox(pdf_in)

		if bboxpage:
			bbox = bbox[bboxpage-1]
		elif smartbbox:
			bboxs = [None] * 4
			for i in range(4):
				bboxs[i] = median(map(lambda x: x[i], bbox))
			bbox = tuple(bboxs)
		else:
			bbox = reduce(lambda x, y: (min(x[0], y[0]), min(x[1], y[1]), max(x[2], y[2]), max(x[3], y[3])), bbox)
	else:
		# x1,y1,x2,y2
		# x,y+w,h
		m = re.match('^(\\d+),(\\d+)(,|\\+)(\\d+),(\\d+)$', args.bbox)
		if not m:
			print 'Invalid bbox format, use x1,y1,x2,y2 or x,y+w,h'
			shutil.rmtree(tmpdir)
			sys.exit(-1)
		else:
			bbox = (int(m.group(1)), int(m.group(2)), int(m.group(4)), int(m.group(5)))
			if m.group(3) == '+':
				bbox = (bbox[0], bbox[1], bbox[0] + bbox[2], bbox[1] + bbox[3])

	w = bbox[2] - bbox[0]
	h = bbox[3] - bbox[1]

	if not a5mode:
		maxw = (a4lwidth - foldmargin - 4 * margins) / 2
		maxh = a4lheight - 2 * margins
		s = float(maxw) / w
		if s * h > maxh:
			# exceeds height, scaling will free up more horizontal space. make sure we use this space where it makes sense (i.e., on the folding edge)
			s = float(maxh) / h
			foldmargin = int(a4lwidth - s * w * 2 - 4 * margins) 

		sm = int(margins / s)
		cbox = (bbox[0] - sm, bbox[1] - sm, bbox[2] + sm, bbox[3] + sm)
	else:
		s_full = float(a5width) / w
		if s_full * h > a5height:
			s_full = float(a5height) / h

		s_page = 1
		if s_full * w > a5width - foldmargin - margins:
			s_page = float(a5width - foldmargin - margins) / (s_full * w)
		if s_page * s_full * h > a5height - 2 * margins:
			s_page = float(a5height - 2 * margins) / (s_full * h)
			foldmargin = int(a5width - margins - s_page * s_full * w)
		cbox = bbox

	# crop crop
	pi = pyPdf.PdfFileReader(file(pdf_in, "rb"))
	pages = pi.getNumPages()
	po = pyPdf.PdfFileWriter()

	for i in range(pages):
		p = pi.getPage(i)
		
		p.cropBox.lowerLeft = (cbox[0] + p.mediaBox.lowerLeft[0], cbox[1] + p.mediaBox.lowerLeft[1])
		p.cropBox.upperRight = (cbox[2] + p.mediaBox.lowerLeft[0], cbox[3] + p.mediaBox.lowerLeft[1])

		p.bleedBox = p.cropBox
		p.trimBox = p.cropBox
		p.artBox = p.cropBox

		po.addPage(p)

	outputStream = file('cropped.pdf', 'wb')
	po.write(outputStream)
	outputStream.close()


tex = file("sig.tex", "w")
if not a5mode:
	if not croponly:
		tex.write("""\\documentclass[a4paper,landscape]{article}
	\\usepackage{pdfpages}
	\\begin{document}
	\\includepdf[pages=-,booklet=true,delta=%dpt 0]{%s}
	\\end{document}""" % (foldmargin, pdf_in if nocrop else 'cropped.pdf'))
	else:
		tex.write("""\\documentclass[a4paper]{article}
	\\usepackage{pdfpages}
	\\begin{document}
	\\includepdf[pages=-]{cropped.pdf}
	\\end{document}""")
	tex.close()
else:
	tex.write("""\\documentclass[a5paper]{article}
	\\usepackage{pdfpages}
	\\begin{document}""")
	for p in range(pages):
		tex.write('\\includepdf[pages=%d,offset=%d 0,scale=%f]{cropped.pdf}' % ((p+1), (foldmargin/2 -margins/2 if (p%2==0) else margins/2 - foldmargin/2), s_page))
	tex.write('\\end{document}')

tex.close()
os.system(texcomp + ' sig.tex')


# apply folding/stapling guides, if available
if not noguides and not croponly:
	f = file('grid.pdf', 'wb')
	f.write(generate_guides(5, a5mode))
	f.close()

	pi = pyPdf.PdfFileReader(file("sig.pdf", "rb"))
	po = pyPdf.PdfFileWriter()

	for i in range(pi.getNumPages()):
		p = pi.getPage(i)
		if i == 0:
			grid = pyPdf.PdfFileReader(file('grid.pdf', 'rb'))
			p.mergePage(grid.getPage(0))
		po.addPage(p)

	outputStream = file('sigs.pdf', 'wb')
	po.write(outputStream)
	outputStream.close()

	os.system(viewer + ' sigs.pdf')
else:
	os.system(viewer + ' sig.pdf')

print 'cleanup:', tmpdir
shutil.rmtree(tmpdir)
